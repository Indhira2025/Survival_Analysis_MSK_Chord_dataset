---
title: "MSK_Chorddata_code_project1"
format: html
editor: visual
---

```{r}

library(dplyr)
library(tidyr)
library(data.table)
library(survival)
#library(randomForestSRC)
library(cluster)
#library(survminer)
library(caret)
library(pROC)



# Reading the clinical patient data

clinical_patient <- read.delim("msk_chord_2024_data/data_clinical_patient.txt", 
                   sep = "\t", 
                   skip = 4,
                   header = TRUE,
                   stringsAsFactors = FALSE)
head(clinical_patient)

names(clinical_patient)
typeof(clinical_patient)
#str(clinical_patient)



clinical_patient[clinical_patient$PATIENT_ID == "P-0001340",]
clinical_features <- clinical_patient %>%
  select(PATIENT_ID,
         GENDER,
         RACE,
         ETHNICITY,
         CURRENT_AGE_DEID,
         SMOKING_PREDICTIONS_3_CLASSES,
         OS_MONTHS,
         OS_STATUS)
clinical_features

```

```{r}

library(kableExtra)
clinical_sample <- read.delim("msk_chord_2024_data/data_clinical_sample.txt", comment.char="#")
View(clinical_sample)
kable(table(clinical_sample$CANCER_TYPE))
names (clinical_sample)

#typeof(clinical_sample)
table(clinical_sample$SAMPLE_TYPE)
#str(clinical_sample)
clinical_sample[clinical_sample$PATIENT_ID == "P-0000041",]
```

names(timeline_diag)

```{r}
timeline_diag <-  read.delim2("msk_chord_2024_data/data_timeline_diagnosis.txt", 
                   header = TRUE, 
                   sep = "\t", 
                   stringsAsFactors = FALSE)
View(timeline_diag)
#unique(timeline_diag$SUBTYPE)
names(timeline_diag)
#unique(timeline_diag$STAGE_CDM_DERIVED)
#unique(timeline_diag$SUMMARY)
#str(timeline_diag)

## 
timeline_diag$SUMMARY <- trimws(timeline_diag$SUMMARY)


## Determine Baseline Stage at Sequencing & Remove Patients Metastatic at Baseline
non_met_baseline <- timeline_diag %>%
  filter(START_DATE <= 0) %>% # all diagnosis records happened before or at genomic                               #baseline.
  group_by(PATIENT_ID) %>%
  slice_max(START_DATE) %>% #What was the Patient's stage at the time of seqencing?
  filter(STAGE_CDM_DERIVED != "Stage 4" ) %>%
  filter(!SUMMARY %in% c("Distant", "Distant metastases/systemic disease"))
#View(baseline_stage)  
#unique(baseline_stage$SUMMARY)

#at-risk cohort

n_distinct(non_met_baseline$PATIENT_ID)

```

```{r}
library(kableExtra)

timeline_progress <-  read.delim("msk_chord_2024_data/data_timeline_progression.txt"
                                , header = TRUE, 
                                sep = "\t", 
                                stringsAsFactors = FALSE)
View(timeline_progress)
#names(timeline_progress)
#str(timeline_progress)
table(timeline_progress$PROGRESSION)


# patients who cannot be included in a time-to-metastasis analysis because they 
## already had metastasis at the time of sequencing.
pre_baseline_met <- timeline_progress %>%
  filter(
    START_DATE <= 0,
    PROGRESSION == "Y"
  ) %>%
  distinct(PATIENT_ID)

## eligible patients from clinical_patient_data

eligible_patients <- clinical_features %>%
  filter(PATIENT_ID %in% non_met_baseline$PATIENT_ID) %>%  
  # keep only non-metastatic at sequencing
  filter(!PATIENT_ID %in% pre_baseline_met$PATIENT_ID)      
  # remove anyone who had metastasis recorded pre-baseline


# Extracting post-baseline metastasis events

met_events <- timeline_progress %>%
  filter(START_DATE > 0,
         PROGRESSION == "Y") %>%
  group_by(PATIENT_ID) %>%
  summarise(first_met_day = min(START_DATE),
            .groups = "drop")
#View(met_events)


# Extarcting  last follow-up time
last_followup <- timeline_progress %>%
  group_by(PATIENT_ID) %>%
  summarise(last_day = max(START_DATE, na.rm = TRUE),
            .groups = "drop")

#View(last_followup)

#=========================================================================
## Time to metastasis event
ttm_data <- eligible_patients %>%
  left_join(met_events, by = "PATIENT_ID") %>%
  left_join(last_followup, by = "PATIENT_ID") %>%
  mutate(
    event = ifelse(!is.na(first_met_day), 1, 0),
    time  = ifelse(event == 1,
                   first_met_day,
                   last_day)
  ) %>%
  filter(!is.na(time),
        time > 0)   #The latest recorded event for this patient happened before                        #sequencing. we have no post-sequencing follow-up data.
                      #This patient cannot contribute meaningful survival info
View(ttm_data)
summary(ttm_data$time)
kable(table(ttm_data$event))
ttm_data
sum(ttm_data$time ==  0)

#===============================================================================

analysis_df <- ttm_data

names(analysis_df)
```

```{r}

### Mutations dataset

mutations <- read.delim("msk_chord_2024_data/data_mutations.txt", 
                   header = TRUE, 
                   sep = "\t", 
                   stringsAsFactors = FALSE)
#View(mutations)
names(mutations)
unique(mutations$Variant_Classification)

## keep mutations that change the protein sequence - nonsynonymous mutations


tmb_df <- clinical_sample %>%
  filter(PATIENT_ID %in% ttm_data$PATIENT_ID)
tmb_patient <- tmb_df %>%
  group_by(PATIENT_ID) %>%
  summarise(max_TMB = max(TMB_NONSYNONYMOUS, na.rm = TRUE),
            .groups = "drop")
nrow(tmb_patient)
length(tmb_patient$PATIENT_ID)
length(unique(tmb_patient$PATIENT_ID))

## Mapping tumor barcode sample ID to patient ID byTumor_Sample_Barcode
mutations_clini_merged <- mutations %>%
  left_join(clinical_sample %>% select(Tumor_Sample_Barcode = SAMPLE_ID, PATIENT_ID ),
            by = "Tumor_Sample_Barcode")
names(mutations_clini_merged)

# Filter mutations for eligible patients
mutations_eligible <- mutations_clini_merged %>%
  filter(PATIENT_ID %in% ttm_data$PATIENT_ID)


nonsynonymous_classes <- c(
  "Missense_Mutation",
  "Nonsense_Mutation",
  "Frame_Shift_Del",
  "Frame_Shift_Ins",
  "frameshift_insertion",
  "In_Frame_Del",
  "In_Frame_Ins",
  "Splice_Site",
  "Translation_Start_Site",
  "Nonstop_Mutation",
  "nonsynonymous_SNV"
)


mutations_eligible_ns <- mutations_eligible %>%
  filter(Variant_Classification %in% nonsynonymous_classes)

mutations_eligible_ns

  
# selecting top 20 mutated genes
top_genes <- mutations_eligible_ns %>%
  count(Hugo_Symbol, sort = TRUE) %>%
  slice_head(n = 20) %>%
  pull(Hugo_Symbol)
top_genes

### Created a Binary Matrix
mutation_matrix <- mutations_eligible_ns %>%
  filter(Hugo_Symbol %in% top_genes) %>%
  distinct(PATIENT_ID, Hugo_Symbol ) %>% #one row per PATIENT_ID.
  mutate(value = 1) %>%
  pivot_wider(
    names_from = Hugo_Symbol,
    values_from = value,
    values_fill = 0
  )
#View(mutation_matrix)
nrow(mutation_matrix)
names(mutation_matrix)




```

```{r}

## Copy number alterations 

cna <- read.table("msk_chord_2024_data/data_cna.txt", 
                   header = TRUE, 
                   sep = "\t", 
                   stringsAsFactors = FALSE)
#View(cna)
names(cna)



library(data.table)
cna_seg <- fread("msk_chord_2024_data/data_cna_hg19.seg")
head(cna_seg)
View(cna_seg)
names(cna_seg)


#Mapping ID to Patient ID
cna_seg_mapped <- cna_seg %>%
  left_join(clinical_sample %>%
              select(SAMPLE_ID, PATIENT_ID),
            by = c("ID" = "SAMPLE_ID"))

# Filter mutations for eligible patients
cna_eligible <- cna_seg_mapped %>%
  filter(PATIENT_ID %in% ttm_data$PATIENT_ID)


## Global cna burden

cna_burden <- cna_eligible %>%
  mutate(
    segment_length = loc.end - loc.start,
    altered = abs(seg.mean) > 0.3
  ) %>%
  group_by(ID, PATIENT_ID) %>%
  summarise(
    total_length = sum(segment_length),
    altered_length = sum(segment_length[altered]),
    global_cna_burden = altered_length / total_length,
    .groups = "drop")

#CNA: global burden per patient (take max per patient)

cna_patient <- cna_burden %>%
  group_by(PATIENT_ID) %>%
  summarise(global_cna_burden = max(global_cna_burden, na.rm = TRUE),
            .groups = "drop")


nrow(cna_patient)
length(cna_patient$PATIENT_ID)
length(unique(cna_patient$PATIENT_ID))
```

```{r}
sv <- read.delim("msk_chord_2024_data/data_sv.txt", 
                   header = TRUE, 
                   sep = "\t", 
                   stringsAsFactors = FALSE)
View(sv)
names(sv)
str(sv)

library(dplyr)
library(tidyr)
library(data.table)

unique(sv$Class)

# --- 2. Map SAMPLE_ID to PATIENT_ID ---
sv_data_mapped <- sv %>%
  left_join(clinical_sample %>% select(SAMPLE_ID, PATIENT_ID),
            by = c("Sample_Id" = "SAMPLE_ID"))

# --- 3. Filter only eligible patients ---
sv_data_filtered <- sv_data_mapped %>%
  filter(PATIENT_ID %in% ttm_data$PATIENT_ID)

# --- 4. Count SVs by type per patient ---
sv_counts <- sv_data_filtered %>%
  group_by(PATIENT_ID, Class) %>%
  summarise(count = n(), .groups = "drop")
View(sv_counts)
table(sv_counts$Class == "", useNA = "ifany")
table(is.na(sv_counts$Class))

# --- 5. Pivot to patient-level feature matrix ---
sv_counts <- sv_counts %>%
  mutate(Class = ifelse(Class == "", "UNKNOWN", Class))

unique(sv_counts$Class)

sv_matrix <- sv_counts %>%
  pivot_wider(names_from = Class,
              values_from = count,
              values_fill = 0)  # missing types get 0

# --- 6. Add total SV count ---
sv_total_count_matrix <- sv_matrix %>%
  rowwise() %>%
  mutate(total_SV_count = sum(c_across(-PATIENT_ID))) %>%
  ungroup()

# --- 7. View final patient-level SV matrix ---

head(sv_total_count_matrix)
nrow(sv_total_count_matrix)
```

```{r}

### Merging ttm data + clinical + Demographic + genomic features of eligible patients

patient_features <- analysis_df %>%
  select(PATIENT_ID, time, event)%>%
  left_join(mutation_matrix, by = "PATIENT_ID") %>%
  left_join(tmb_patient, by = "PATIENT_ID") %>%
  left_join(cna_patient, by = "PATIENT_ID") %>%
  left_join(sv_total_count_matrix, by = "PATIENT_ID")
patient_features[is.na(patient_features)] <- 0

#View(analysis_df)

kable(table(patient_features$event))

###==================Final table for RFS analysis=====================
patient_features

nrow(patient_features)
n_distinct(analysis_df$PATIENT_ID)
patient_features[patient_features$time == 0,]

####======================================================================
#View(patient_features)
```

```{r}
### RSF Clustering

#Create a survival object
#install.packages("randomForestSRC")
library(randomForestSRC)
library(survival)
surv_obj <- Surv(time = patient_features$time, # creates the correct structure                                                                              required 
                 event = patient_features$event) # for RSF or cox regression




# Remove ID column for modeling
rsf_data <- patient_features %>%
  select(-PATIENT_ID)

# Fit RSF
set.seed(123)

rsf_model <- rfsrc(
  Surv(time, event) ~ .,
  data = rsf_data,
  ntree = 1000,
  proximity = TRUE
)

prox_matrix <- rsf_model$proximity
View(prox_matrix)
dim(prox_matrix)

# Create distance Matrix

dist_matrix <- 1 - prox_matrix
dist_matrix

# create distance object
dist_obj <- as.dist(dist_matrix)
dist_obj

# Determine Optimal Number of Clusters (Silhouette Method)

library(cluster)

sil_width <- c()

for (k in 2:6) {
  pam_fit <- pam(dist_obj, k = k, diss = TRUE)
  sil_width[k] <- pam_fit$silinfo$avg.width
}

plot(2:6, sil_width[2:6], type = "b",
     xlab = "Number of clusters",
     ylab = "Average Silhouette Width")
optimal_k <- which.max(sil_width)
optimal_k

```

```{r}
#Final Clustering (PAM)
pam_final <- pam(dist_obj,
                 k = optimal_k,
                 diss = TRUE)

patient_features$cluster <- factor(pam_final$clustering)
#patient_features$cluster

```

```{r}

# Validate Survival Separation

fit <- survfit(Surv(time, event) ~ cluster,
               data = patient_features)

plot(fit, col = 1:optimal_k, lwd = 2,
     xlab = "Time",
     ylab = "MFS Probability")

legend("bottomleft",
       legend = levels(patient_features$cluster),
       col = 1:optimal_k,
       lwd = 2)

#=============================================================================
### This is a log-rank test, which tests:

###Are survival (time-to-metastasis) curves different across clusters?


survdiff(Surv(time, event) ~ cluster,
         data = patient_features)
```
```{r}

### Patient_clusters 
patient_clusters <- patient_features %>%
  group_by(cluster) %>%
  summarise(across(where(is.numeric), mean))

kable(patient_clusters)

```
This looks like:

KRAS + TP53 + SMAD4 co-altered aggressive phenotype

This pattern is typical of very unstable tumors.

Cluster 5 likely represents:

Genomically unstable
Strong oncogenic signaling
High metastatic potential

RSF clustering has separated:

cluster5:  TP53+KRAS+SMAD4 aggressive subtype

cluster 6: TP53+KRAS-only subtype

cluster3 :  TP53-only subtype

cluster4 : KRAS-only subtype

cluster2: Genomically quiet subtype

cluster 1: Intermediate complex subtype

This is biologically meaningful.

This is not random clustering.
This reflects oncogenic architecture.

shorter:

We trained a Random Survival Forest (RSF) using patient-level genomic features—including nonsynonymous mutations, structural variant counts, and global copy number alteration burden—as predictors, with time-to-metastasis and event status as the outcome. The forest was grown with 1,000 trees, and out-of-bag (OOB) samples were used to obtain unbiased error estimates and to compute a patient-level proximity matrix reflecting survival-relevant similarity. The proximity matrix was converted to a distance matrix and used for hierarchical clustering, with the optimal number of clusters determined by silhouette width and stability analysis. Resulting clusters were interpreted as genomic phenotypes informed by shared survival-associated patterns.

## Methods

### Patient Cohort and Data Preprocessing

Clinical and genomic data for patients were obtained from the MSK CHORD cohort. Patients with metastasis at or prior to the time of sequencing were excluded to ensure analysis of post-sequencing outcomes. Clinical covariates including age, sex, race, and smoking status were retained for descriptive purposes but not included in the genomic clustering model. Genomic features included nonsynonymous somatic mutations (top 20 most frequently mutated genes), global copy number alteration (CNA) burden, and structural variant counts. For patients with multiple tumor samples, features were aggregated at the patient level, and missing values were imputed as zero.

### Random Survival Forest Model

A Random Survival Forest (RSF) was trained using the `randomForestSRC` R package. Time-to-metastasis and event status were specified as the outcome, and patient-level genomic features were used as predictors. The forest was grown with 1,000 trees to ensure model stability. Out-of-bag (OOB) samples, which are the patients excluded from each bootstrap sample used to grow individual trees, were leveraged to provide unbiased estimates of prediction error and to calculate a patient-level proximity matrix. The proximity matrix captures survival-relevant similarity between patients, based on how frequently pairs of patients co-occur in the same terminal nodes across trees.

### Patient Clustering

The OOB-based RSF proximity matrix was transformed into a dissimilarity (distance) matrix by subtracting the proximity values from 1. This distance matrix was used as input for hierarchical clustering with complete linkage. The optimal number of clusters was determined using silhouette width and cluster stability analysis via resampling. Resulting clusters were interpreted as **genomic phenotypes informed by survival structure**, reflecting shared survival-relevant genomic patterns among patients.

### Statistical Analyses

OOB error rates from the RSF were monitored to ensure sufficient forest size and stability. Cluster-specific survival curves were estimated using Kaplan-Meier analysis, and differences between clusters were assessed using the log-rank test. All analyses were conducted in R (version X.X) using the `dplyr`, `tidyr`, and `randomForestSRC` packages.

### Interpretation:

-   Extremely large chi-square statistic
p-value essentially 0
Strong evidence that survival differs across clusters
 RSF-derived clusters are **survival-informative**.

```{r}
gene_panel <- read.table("msk_chord_2024_data/data_gene_panel_matrix.txt", 
                   header = TRUE, 
                   sep = "\t", 
                   stringsAsFactors = FALSE)
#View(gene_panel)
names(gene_panel)
library(jsonlite)
impact341 <- fromJSON("https://www.cbioportal.org/api/gene-panels/IMPACT341")$genes$hugoGeneSymbol
impact410 <- fromJSON("https://www.cbioportal.org/api/gene-panels/IMPACT410")$genes$hugoGeneSymbol
impact468 <- fromJSON("https://www.cbioportal.org/api/gene-panels/IMPACT468")$genes$hugoGeneSymbol
impact505 <- fromJSON("https://www.cbioportal.org/api/gene-panels/IMPACT505")$genes$hugoGeneSymbol

# Create a lookup list if you want
panel_genes <- list(
  IMPACT341 = impact341,
  IMPACT410 = impact410,
  IMPACT468 = impact468,
  IMPACT505 = impact505
)
panel_genes
```

```{r}
TumorSites <- read.delim("msk_chord_2024_data/data_timeline_tumor_sites.txt")
View(TumorSites)
head(TumorSites)
names(TumorSites)
TumorSites[TumorSites$PATIENT_ID == "P-0000012",]
```

```{r}
treatment <- read.delim("msk_chord_2024_data/data_timeline_treatment.txt")
#View(treatment)
head(treatment)
names(treatment)
```

```{r}
radiation <- read.delim("msk_chord_2024_data/data_timeline_radiation.txt")
#View(radiation)
head(radiation)
names(radiation)
```

```{r}
surgery <- read.delim("msk_chord_2024_data/data_timeline_surgery.txt")
head(surgery)
names(surgery)
```

```{r}
prior_meds<- read.delim("msk_chord_2024_data/data_timeline_prior_meds.txt")
#View(prior_meds)
head(prior_meds)
names(prior_meds)
```

```{r}
psa <- read.delim("msk_chord_2024_data/data_timeline_psa_labs.txt")
#View(psa)
head(psa)
names(psa)
```

```{r}


names(clinical_patient)
#str(clinical_patient)
names (clinical_sample)
#str(clinical_sample)
names(timeline_diag)
#str(timeline_diag)
names(cna_seg)

names(mutations)
names(sv)
names(gene_panel)
names(timeline_progress)
names(TumorSites)
names(treatment)
names(radiation)
names(surgery)
names(prior_meds)
names(psa)


str(clinical_patient)
str(clinical_sample)
str(timeline_diag)
str(cna_seg)
str(mutations)
str(sv)
str(gene_panel)
str(timeline_progress)
str(TumorSites)
str(treatment)
str(radiation)
str(surgery)
str(prior_meds)
str(psa)

```
